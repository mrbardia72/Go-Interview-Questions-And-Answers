[منبع](https://ditty.ir/) 
<h2  dir="rtl"> 🌱  اصل تک مسئولیتی (Single Responsibility Principle)  </h2>  
 <p  dir="rtl">
هر کلاسی که توی برنامه‌ی ما وجود داره، باید یک مسئولیت خاص و مشخص داشته. در واقع این کلاس باید فقط و فقط مسئول یک عملکرد توی برنامه باشه 
<br><br>
کلاس ما باید معنی دار باشد و متدهای که داخلش تعریف میشه یک کار واحد رو انجام بده در حوزه مثلن کاربران نباید توش از متدهای که مربوط به ارسال پست میشه استفاده کرد باید توی حوزه خودش باشه و کارهای که بهش داده میشه معنی داره و تک مسولیتی باشه
<br><br>
نکته: این اصل نه تنها توی سطح کلاس‌ها، بلکه توی سطح متدها و توابع هم می‌تونه اعمال بشه

</p>

---
[منبع](https://ditty.ir/)
<h2  dir="rtl"> 🌱   اصل باز/بسته یا Open/Closed Principle  </h2>  
 <p  dir="rtl">
موجودیت‌های یک نرم‌افزار (کلاس‌ها، ماژول‌ها، توابع و ...) باید برای توسعه داده شدن، باز و برای تغییر دادن، بسته باشن
<br>در واقعه
اصل OCP میگه که ما باید کد رو جوری بنویسیم که وقتی می‌خوایم اون رو توسعه بدیم و ویژگی‌های جدید اضافه کنیم، مجبور نشیم اون رو تغییر بدیم و دستکاری کنیم. ویژگی‌های جدید باید براحتی و بدون دستکاری کردن قسمت‌های دیگه اضافه بشن.
<br><br>
چه زمانی به یک کلاس می‌گیم باز؟
<br>
به کلاسی که بشه اون رو توسعه داد، بشه از اون extend کرد، متدها و پراپرتی‌های جدید اضافه کرد و ویژگی‌ها و رفتار اون رو تغییر داد، میگن باز.
<br><br>
چه زمانی به یک کلاس میگیم بسته؟
<br>
کلاسی که کامل باشه. یعنی 100% تست شده باشه که بتونه توسط بقیه کلاس‌ها استفاده بشه، پایدار باشه و در آینده تغییر نکنه. توی بعضی از زبان‌های برنامه‌نویسی یکی از راه‌های بسته نگه داشتن یک کلاس، استفاده از کلمه کلیدی final هست.
 </p>

---
[منبع](https://ditty.ir/)
<h2  dir="rtl"> 🌱  اصل جایگزینی لیسکوف یا Liskov Substitution Principle  </h2>  
 <p  dir="rtl">
اگر S یک زیر کلاس از  T باشه، آبجکت‌های نوع T باید بتونن بدون تغییر دادن کد برنامه با آبجکت‌های نوع S جایگزین بشن
 </p>

---
[منبع](https://ditty.ir/)
<h2  dir="rtl"> 🌱 اصل جداسازی اینترفیس‌ها یا Interface Segregation Principle    </h2>  
 <p  dir="rtl">
کلاس‌ها نباید مجبور باشن متدهایی که به اونها احتیاجی ندارن رو پیاده‌سازی کنن
<br>
این اصل میگه که ما باید اینترفیس (Interface) ها رو جوری بنویسیم که وقتی یک کلاس از اون استفاده میکنه، مجبور نباشه متدهایی که لازم نداره رو پیاده‌سازی کنه. یعنی متدهای بی‌ربط نباید توی یک اینترفیس کنار هم باشن. این اصل شباهت زیادی به اصل اول SOLID داره که میگه کلاس‌ها باید فقط مسئول انجام یک کار باشن.

 </p>

---
[منبع](https://ditty.ir/)
<h2  dir="rtl"> 🌱 اصل وارونگی وابستگی (Dependency Inversion Principle)    </h2>  
 <p  dir="rtl">
کلاس‌های سطح بالا نباید به کلاس‌های سطح پایین وابسته باشن؛ هر دو باید وابسته به انتزاع (Abstractions) باشن.
<br><br>
کلاس سطح پایین چیه؟
<br>
به کلاس‌هایی گفته میشه که مسئول عملیات اساسی و پایه‌ای توی نرم‌افزار هستن. مثل کلاسی که با دیتابیس یا هارددیسک ارتباط برقرار می‌کنه، کلاسی که برای ارسال ایمیل استفاده میشه
<br><br>
کلاس سطح بالا؟
<br>
کلاس‌هایی که عملیات پیچیده‌تر و خاص‌تری انجام میدن و برای انجام این کار از کلاس‌های سطح پایین استفاده میکنن. برای مثال کلاس گزارش‌گیری برای ثبت و خوندن گزارش، به کلاس دیتابیس یا هارددیسک نیاز داره. کلاس Users، برای اطلاع‌رسانی به کاربرها به کلاس ایمیل نیاز داره.
<br><br>
مفهوم انتزاع (Abstraction)
<br>
کلاس‌های انتزاعی کلاس‌های هستن که قابل پیاده‌سازی نیستن اما به عنوان یک طرح و الگو برای کلاس‌های دیگه در نظر گرفته میشن.
 </p>

---
